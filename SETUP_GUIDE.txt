WurkWurk - Detailed Setup Guide

This guide provides step-by-step instructions to connect the WurkWurk Chrome extension to your own private Google Sheet.

Step 1: Create Your Google Sheet

Go to sheets.google.com.

Click on Blank to create a new spreadsheet.

Give the spreadsheet a name you'll remember, like "My WurkWurk Logs."

Step 2: Add Headers to the Sheet

This is a critical step. The script requires nine specific headers in the first row, in this exact order, to function correctly.

In cell A1, type: Date

In cell B1, type: Time

In cell C1, type: Log Entry

In cell D1, type: Tag

In cell E1, type: Drifted

In cell F1, type: Mins Since Last

In cell G1, type: FullTimestamp

In cell H1, type: Domain

In cell I1, type: Reactive

Your sheet's first row should look like this:

A

B

C

D

E

F

G

H

I

Date

Time

Log Entry

Tag

Drifted

Mins Since Last

FullTimestamp

Domain

Reactive

Step 3: Create the Google Apps Script

This script will act as the secure bridge between the Chrome extension and your Google Sheet.

In your Google Sheet, click Extensions > Apps Script.

A new browser tab will open with the Apps Script editor.

Step 4: Paste the Script Code

Delete any placeholder code in the Code.gs file (e.g., function myFunction() { ... }).

Copy the entire script below and paste it into the empty Code.gs editor.

/**
 * @file Google Apps Script for WurkWurk Chrome Extension (v3.0 with Dashboard Support)
 * @description This script receives data from the Chrome extension and logs it to a Google Sheet.
 * It also provides data for the dashboard's "Weekly Review" tab.
 */

// --- CONFIGURATION ---

/**
 * @const {string}
 * @description The time zone for formatting dates and times.
 * Find your time zone here: [https://en.wikipedia.org/wiki/List_of_tz_database_time_zones](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones)
 * @example "America/New_York", "Europe/London", "Asia/Tokyo"
 */
const TIME_ZONE = "Europe/Vilnius";

/**
 * @const {string}
 * @description The name of the sheet (the tab at the bottom) where logs will be added.
 * IMPORTANT: If you rename your sheet, you must update this value.
 */
const SHEET_NAME = "Sheet1";

// --- END CONFIGURATION ---


/**
 * @description Handles GET requests for both connection testing and fetching dashboard data.
 * @param {object} e - The event parameter containing the request details.
 * @returns {ContentService.TextOutput} A JSON response.
 */
function doGet(e) {
  try {
    // Action: Test Connection
    if (e.parameter.action === "test") {
      Logger.log("WurkWurk: Received successful test ping.");
      return ContentService.createTextOutput(
        JSON.stringify({
          status: "success",
          message: "Connection successful!",
        })
      ).setMimeType(ContentService.MimeType.JSON);
    }

    // Action: Get Weekly Data for Dashboard
    if (e.parameter.action === "getWeeklyData") {
      const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(SHEET_NAME);
      if (!sheet) {
        throw new Error(`Sheet not found: ${SHEET_NAME}`);
      }
      const data = sheet.getDataRange().getValues();
      const header = data.shift(); // Remove header row

      const thirtyDaysAgo = new Date();
      thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
      const recentData = data.filter(row => new Date(row[6]) >= thirtyDaysAgo);

      // --- Calculate Stats ---

      // 1. Tag Pie Chart Data (Count occurrences)
      const tagCounts = recentData.reduce((acc, row) => {
        const tag = row[3] || "Untagged"; // Column D
        acc[tag] = (acc[tag] || 0) + 1;
        return acc;
      }, {});
      const tagData = {
        labels: Object.keys(tagCounts),
        values: Object.values(tagCounts)
      };

      // 2. Keyword Bar Chart Data
      const stopWords = new Set(["a", "an", "the", "and", "in", "on", "for", "with", "to", "is", "of", "it", "i", "was"]);
      const keywordCounts = recentData.reduce((acc, row) => {
        const log = (row[2] || "").toLowerCase(); // Column C
        const words = log.match(/\b(\w+)\b/g) || [];
        words.forEach(word => {
          if (word.length > 3 && !stopWords.has(word) && !/\d+/.test(word)) {
            acc[word] = (acc[word] || 0) + 1;
          }
        });
        return acc;
      }, {});
      const sortedKeywords = Object.entries(keywordCounts).sort(([,a],[,b]) => b-a).slice(0, 10);
      const keywordData = {
        labels: sortedKeywords.map(item => item[0]),
        values: sortedKeywords.map(item => item[1])
      };

      // 3. Focus Over Time Data (Last 7 days)
      const focusByDay = {};
      for (let i = 6; i >= 0; i--) {
        const d = new Date();
        d.setDate(d.getDate() - i);
        const dayString = d.toLocaleDateString('en-US', { weekday: 'short' });
        focusByDay[dayString] = { total: 0, drifted: 0 };
      }

      const sevenDaysAgo = new Date();
      sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);
      const last7DaysData = recentData.filter(row => new Date(row[6]) >= sevenDaysAgo);

      last7DaysData.forEach(row => {
          const date = new Date(row[6]); // Column G
          const dayString = date.toLocaleDateString('en-US', { weekday: 'short' });
          if (focusByDay[dayString]) {
            focusByDay[dayString].total++;
            if (row[4] === "Yes") { // Column E is Drifted
              focusByDay[dayString].drifted++;
            }
          }
      });

      const focusData = {
        labels: Object.keys(focusByDay),
        values: Object.values(focusByDay).map(day => {
          if (day.total === 0) return 0;
          return Math.round(((day.total - day.drifted) / day.total) * 100);
        })
      };

      // --- Assemble Response ---
      const responseData = { tagData, keywordData, focusData };
      return ContentService.createTextOutput(
        JSON.stringify({ status: "success", data: responseData })
      ).setMimeType(ContentService.MimeType.JSON);
    }

  } catch (err) {
    Logger.log("WurkWurk: doGet Error - " + err.message);
    return ContentService.createTextOutput(
      JSON.stringify({ status: "error", message: err.message })
    ).setMimeType(ContentService.MimeType.JSON);
  }
  
  return ContentService.createTextOutput(
    JSON.stringify({ status: "error", message: "Invalid request. Use POST to log data." })
  ).setMimeType(ContentService.MimeType.JSON);
}


/**
 * @description Handles POST requests from the Chrome extension to log new data.
 * @param {object} e - The event parameter containing the POST data.
 * @returns {ContentService.TextOutput} A JSON response indicating success or failure.
 */
function doPost(e) {
  let sheet;
  try {
    const data = JSON.parse(e.postData.contents);
    const logEntry = data.log || "";
    const tag = data.tag || "";
    const drifted = data.drifted ? "Yes" : "No";
    const domain = data.domain || "";
    const reactive = data.reactive ? "Yes" : "No";
    
    sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(SHEET_NAME);
    if (!sheet) {
      throw new Error(`Sheet not found. Please ensure a sheet named "${SHEET_NAME}" exists.`);
    }
    
    const now = new Date();
    const fullTimestamp = now.toISOString();
    const dateFormatted = Utilities.formatDate(now, TIME_ZONE, "yyyy-MM-dd");
    const timeFormatted = Utilities.formatDate(now, TIME_ZONE, "HH:mm:ss");

    let minsSinceLast = "N/A";
    const lastRow = sheet.getLastRow();
    
    if (lastRow >= 1) {
      const lastTimestampStr = sheet.getRange(lastRow, 7).getValue(); 
      if (lastTimestampStr) {
        const lastTimestamp = new Date(lastTimestampStr);
        const diffMs = now.getTime() - lastTimestamp.getTime();
        minsSinceLast = Math.round(diffMs / 60000);
      }
    }

    const newRow = [
      dateFormatted, dateFormatted, logEntry, tag, drifted,
      minsSinceLast, fullTimestamp, domain, reactive
    ];
    
    sheet.appendRow(newRow);

    return ContentService.createTextOutput(
      JSON.stringify({ status: "success", row: sheet.getLastRow() })
    ).setMimeType(ContentService.MimeType.JSON);

  } catch (err) {
    Logger.log("WurkWurk: doPost Error - " + err.message);
    return ContentService.createTextOutput(
      JSON.stringify({ status: "error", message: err.message, sheetName: SHEET_NAME })
    ).setMimeType(ContentService.MimeType.JSON);
  }
}


IMPORTANT: Find the line const TIME_ZONE = "Europe/Vilnius"; and change the time zone to your own if it's incorrect (e.g., "America/New_York").

Save the script by clicking the floppy disk icon or pressing Ctrl+S.

Step 5: Deploy the Script as a Web App

This step creates the secret URL the extension will use to send data to your sheet.

***IF YOU ARE UPDATING FROM A PREVIOUS VERSION, YOU MUST RE-DEPLOY TO APPLY THE CHANGES.***

In the Apps Script editor, click the blue Deploy button in the top-right corner.

Select New deployment. (If you are re-deploying, select 'Manage Deployments', choose your deployment, and click the pencil icon to edit it. Set the version to 'New version'.)

Click the gear icon (⚙️) next to "Select type" and choose Web app.

In the dialog box, enter the following settings:

Description: WurkWurk Log Receiver (Optional)

Execute as: Me (This is very important).

Who has access: Anyone (This does NOT make your sheet public. It only allows someone with the secret, complex URL to send data to the script).

Click Deploy.

Step 6: Authorize the Script

Google will prompt you to authorize the script. Click Authorize access.

Choose your Google account.

You will likely see a "Google hasn't verified this app" warning. This is normal for personal scripts. Click Advanced, then click "Go to [Your Script Name] (unsafe)".

Click Allow to grant the script permission to edit your spreadsheets.

Step 7: Copy the Web App URL

After deployment is complete, a dialog box will appear with the Web app URL.

COPY THIS URL. You will need it for the final step.

Step 8: Configure the Extension

Go to your Chrome extensions page by navigating to chrome://extensions.

Find the "WurkWurk" extension.

Right-click the extension's icon in your Chrome toolbar and click Options.

On the settings page:

Paste the Web app URL you copied into the first field, "Google Apps Script URL."

Click the Test button next to it. You should see a green "Success!" message. If not, double-check your script deployment and URL.

Configure your other preferences, such as the log interval and notification sound.

Scroll to the bottom and click Save Settings.

You are all set! The extension is now fully configured and will start prompting you at your chosen interval during your working hours.
